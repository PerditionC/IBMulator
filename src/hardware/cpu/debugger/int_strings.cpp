/*
 * Copyright (C) 2018  Marco Bortolin
 *
 * This file is part of IBMulator.
 *
 * IBMulator is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * IBMulator is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with IBMulator.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "ibmulator.h"
#include "../debugger.h"

doscodes_map_t CPUDebugger::ms_dos_errors = {
	{ 0x00, "no error" },
	{ 0x01, "function number invalid" },
	{ 0x02, "file not found" },
	{ 0x03, "path not found" },
	{ 0x04, "too many open files (no handles available)" },
	{ 0x05, "access denied" },
	{ 0x06, "invalid handle" },
	{ 0x07, "memory control block destroyed" },
	{ 0x08, "insufficient memory" },
	{ 0x09, "memory block address invalid" },
	{ 0x0A, "environment invalid (usually >32K in length)" },
	{ 0x0B, "format invalid" },
	{ 0x0C, "access code invalid" },
	{ 0x0D, "data invalid" },
	{ 0x0E, "reserved" },
	{ 0x0E, "(PTS-DOS 6.51+, S/DOS 1.0+) fixup overflow" },
	{ 0x0F, "invalid drive" },
	{ 0x10, "attempted to remove current directory" },
	{ 0x11, "not same device" },
	{ 0x12, "no more files" },
	{ 0x13, "disk write-protected" },
	{ 0x14, "unknown unit" },
	{ 0x15, "drive not ready" },
	{ 0x16, "unknown command" },
	{ 0x17, "data error (CRC)" },
	{ 0x18, "bad request structure length" },
	{ 0x19, "seek error" },
	{ 0x1A, "unknown media type (non-DOS disk)" },
	{ 0x1B, "sector not found" },
	{ 0x1C, "printer out of paper" },
	{ 0x1D, "write fault" },
	{ 0x1E, "read fault" },
	{ 0x1F, "general failure" },
	{ 0x20, "sharing violation" },
	{ 0x21, "lock violation" },
	{ 0x22, "disk change invalid (ES:DI -> media ID structure)(see #01681)" },
	{ 0x23, "FCB unavailable" },
	{ 0x23, "(PTS-DOS 6.51+, S/DOS 1.0+) bad FAT" },
	{ 0x24, "sharing buffer overflow" },
	{ 0x25, "(DOS 4.0+) code page mismatch" },
	{ 0x26, "(DOS 4.0+) cannot complete file operation (EOF / out of input)" },
	{ 0x27, "(DOS 4.0+) insufficient disk space" },
	{ 0x28, "reserved" },
	{ 0x29, "reserved" },
	{ 0x2A, "reserved" },
	{ 0x2B, "reserved" },
	{ 0x2C, "reserved" },
	{ 0x2D, "reserved" },
	{ 0x2E, "reserved" },
	{ 0x2F, "reserved" },
	{ 0x30, "reserved" },
	{ 0x31, "reserved" },
	{ 0x32, "network request not supported" },
	{ 0x33, "remote computer not listening" },
	{ 0x34, "duplicate name on network" },
	{ 0x35, "network name not found" },
	{ 0x36, "network busy" },
	{ 0x37, "network device no longer exists" },
	{ 0x38, "network BIOS command limit exceeded" },
	{ 0x39, "network adapter hardware error" },
	{ 0x3A, "incorrect response from network" },
	{ 0x3B, "unexpected network error" },
	{ 0x3C, "incompatible remote adapter" },
	{ 0x3D, "print queue full" },
	{ 0x3E, "queue not full" },
	{ 0x3F, "not enough space to print file" },
	{ 0x40, "network name was deleted" },
	{ 0x41, "network: Access denied / codepage switching not possible" },
	{ 0x42, "network device type incorrect" },
	{ 0x43, "network name not found" },
	{ 0x44, "network name limit exceeded" },
	{ 0x45, "network BIOS session limit exceeded" },
	{ 0x46, "temporarily paused" },
	{ 0x47, "network request not accepted" },
	{ 0x48, "network print/disk redirection paused" },
	{ 0x49, "network software not installed" },
	{ 0x4A, "unexpected adapter close" },
	{ 0x4B, "(LANtastic) password expired" },
	{ 0x4C, "(LANtastic) login attempt invalid at this time" },
	{ 0x4D, "(LANtastic v3+) disk limit exceeded on network node" },
	{ 0x4E, "(LANtastic v3+) not logged in to network node" },
	{ 0x4F, "reserved" },
	{ 0x50, "file exists" },
	{ 0x51, "(undoc) duplicated FCB" },
	{ 0x52, "cannot make directory" },
	{ 0x53, "fail on INT 24h" },
	{ 0x54, "(DOS 3.3+) too many redirections / out of structures" },
	{ 0x55, "(DOS 3.3+) duplicate redirection / already assigned" },
	{ 0x56, "(DOS 3.3+) invalid password" },
	{ 0x57, "(DOS 3.3+) invalid parameter" },
	{ 0x58, "(DOS 3.3+) network write fault" },
	{ 0x59, "(DOS 4.0+) function not supported on network / no process slots available" },
	{ 0x5A, "(DOS 4.0+) required system component not installed / not frozen" },
	{ 0x5B, "(DOS 4.0+,NetWare4) timer server table overflowed" },
	{ 0x5C, "(DOS 4.0+,NetWare4) duplicate in timer service table" },
	{ 0x5D, "(DOS 4.0+,NetWare4) no items to work on" },
	{ 0x5F, "(DOS 4.0+,NetWare4) interrupted / invalid system call" },
	{ 0x64, "(MSCDEX) unknown error" },
	{ 0x64, "(DOS 4.0+,NetWare4) open semaphore limit exceeded" },
	{ 0x65, "(MSCDEX) not ready" },
	{ 0x65, "(DOS 4.0+,NetWare4) exclusive semaphore is already owned" },
	{ 0x66, "(MSCDEX) EMS memory no longer valid" },
	{ 0x66, "(DOS 4.0+,NetWare4) semaphore was set when close attempted" },
	{ 0x67, "(MSCDEX) not High Sierra or ISO-9660 format" },
	{ 0x67, "(DOS 4.0+,NetWare4) too many exclusive semaphore requests" },
	{ 0x68, "(MSCDEX) door open" },
	{ 0x68, "(DOS 4.0+,NetWare4) operation invalid from interrupt handler" },
	{ 0x69, "(DOS 4.0+,NetWare4) semaphore owner died" },
	{ 0x6A, "(DOS 4.0+,NetWare4) semaphore limit exceeded" },
	{ 0x6B, "(DOS 4.0+,NetWare4) insert drive B: disk into A: / disk changed" },
	{ 0x6C, "(DOS 4.0+,NetWare4) drive locked by another process" },
	{ 0x6D, "(DOS 4.0+,NetWare4) broken pipe" },
	{ 0x6E, "(DOS 5.0+,NetWare4) pipe open/create failed" },
	{ 0x6F, "(DOS 5.0+,NetWare4) pipe buffer overflowed" },
	{ 0x70, "(DOS 5.0+,NetWare4) disk full" },
	{ 0x71, "(DOS 5.0+,NetWare4) no more search handles" },
	{ 0x72, "(DOS 5.0+,NetWare4) invalid target handle for dup2" },
	{ 0x73, "(DOS 5.0+,NetWare4) bad user virtual address / protection violation" },
	{ 0x74, "(DOS 5.0+) VIOKBD request" },
	{ 0x74, "(NetWare4) error on console I/O" },
	{ 0x75, "(DOS 5.0+,NetWare4) unknown category code for IOCTL" },
	{ 0x76, "(DOS 5.0+,NetWare4) invalid value for verify flag" },
	{ 0x77, "(DOS 5.0+,NetWare4) level four driver not found by DOS IOCTL" },
	{ 0x78, "(DOS 5.0+,NetWare4) invalid / unimplemented function number" },
	{ 0x79, "(DOS 5.0+,NetWare4) semaphore timeout" },
	{ 0x7A, "(DOS 5.0+,NetWare4) buffer too small to hold return data" },
	{ 0x7B, "(DOS 5.0+,NetWare4) invalid character or bad file-system name" },
	{ 0x7C, "(DOS 5.0+,NetWare4) unimplemented information level" },
	{ 0x7D, "(DOS 5.0+,NetWare4) no volume label found" },
	{ 0x7E, "(DOS 5.0+,NetWare4) module handle not found" },
	{ 0x7F, "(DOS 5.0+,NetWare4) procedure address not found" },
	{ 0x80, "(DOS 5.0+,NetWare4) CWait found no children" },
	{ 0x81, "(DOS 5.0+,NetWare4) CWait children still running" },
	{ 0x82, "(DOS 5.0+,NetWare4) invalid operation for direct disk-access handle" },
	{ 0x83, "(DOS 5.0+,NetWare4) attempted seek to negative offset" },
	{ 0x84, "(DOS 5.0+,NetWare4) attempted to seek on device or pipe" },
	{ 0x85, "(DOS 5.0+,NetWare4) drive already has JOINed drives" },
	{ 0x86, "(DOS 5.0+,NetWare4) drive is already JOINed" },
	{ 0x87, "(DOS 5.0+,NetWare4) drive is already SUBSTed" },
	{ 0x88, "(DOS 5.0+,NetWare4) can not delete drive which is not JOINed" },
	{ 0x89, "(DOS 5.0+,NetWare4) can not delete drive which is not SUBSTed" },
	{ 0x8A, "(DOS 5.0+,NetWare4) can not JOIN to a JOINed drive" },
	{ 0x8B, "(DOS 5.0+,NetWare4) can not SUBST to a SUBSTed drive" },
	{ 0x8C, "(DOS 5.0+,NetWare4) can not JOIN to a SUBSTed drive" },
	{ 0x8D, "(DOS 5.0+,NetWare4) can not SUBST to a JOINed drive" },
	{ 0x8E, "(DOS 5.0+,NetWare4) drive is busy" },
	{ 0x8F, "(DOS 5.0+,NetWare4) can not JOIN/SUBST to same drive" },
	{ 0x90, "(DOS 5.0+,NetWare4) directory must not be root directory" },
	{ 0x91, "(DOS 5.0+,NetWare4) can only JOIN to empty directory" },
	{ 0x92, "(DOS 5.0+,NetWare4) path is already in use for SUBST" },
	{ 0x93, "(DOS 5.0+,NetWare4) path is already in use for JOIN" },
	{ 0x94, "(DOS 5.0+,NetWare4) path is in use by another process" },
	{ 0x95, "(DOS 5.0+,NetWare4) directory previously SUBSTituted" },
	{ 0x96, "(DOS 5.0+,NetWare4) system trace error" },
	{ 0x97, "(DOS 5.0+,NetWare4) invalid event count for DosMuxSemWait" },
	{ 0x98, "(DOS 5.0+,NetWare4) too many waiting on mutex" },
	{ 0x99, "(DOS 5.0+,NetWare4) invalid list format" },
	{ 0x9A, "(DOS 5.0+,NetWare4) volume label too large" },
	{ 0x9B, "(DOS 5.0+,NetWare4) unable to create another TCB" },
	{ 0x9C, "(DOS 5.0+,NetWare4) signal refused" },
	{ 0x9D, "(DOS 5.0+,NetWare4) segment discarded" },
	{ 0x9E, "(DOS 5.0+,NetWare4) segment not locked" },
	{ 0x9F, "(DOS 5.0+,NetWare4) invalid thread-ID address" },
	{ 0xA0, "(DOS 5.0+) bad arguments" },
	{ 0xA0, "(NetWare4) bad environment pointer" },
	{ 0xA1, "(DOS 5.0+,NetWare4) invalid pathname passed to EXEC" },
	{ 0xA2, "(DOS 5.0+,NetWare4) signal already pending" },
	{ 0xA3, "(DOS 5.0+) uncertain media" },
	{ 0xA3, "(NetWare4) ERROR_124 mapping" },
	{ 0xA4, "(DOS 5.0+) maximum number of threads reached" },
	{ 0xA4, "(NetWare4) no more process slots" },
	{ 0xA5, "(NetWare4) ERROR_124 mapping" },
	{ 0xB0, "(MS-DOS 7.0) volume is not locked" },
	{ 0xB1, "(MS-DOS 7.0) volume is locked in drive" },
	{ 0xB2, "(MS-DOS 7.0) volume is not removable" },
	{ 0xB4, "(MS-DOS 7.0) lock count has been exceeded" },
	{ 0xB4, "(NetWare4) invalid segment number" },
	{ 0xB5, "(MS-DOS 7.0) a valid eject request failed" },
	{ 0xB5, "(DOS 5.0-6.0,NetWare4) invalid call gate" },
	{ 0xB6, "(DOS 5.0+,NetWare4) invalid ordinal" },
	{ 0xB7, "(DOS 5.0+,NetWare4) shared segment already exists" },
	{ 0xB8, "(DOS 5.0+,NetWare4) no child process to wait for" },
	{ 0xB9, "(DOS 5.0+,NetWare4) NoWait specified and child still running" },
	{ 0xBA, "(DOS 5.0+,NetWare4) invalid flag number" },
	{ 0xBB, "(DOS 5.0+,NetWare4) semaphore does not exist" },
	{ 0xBC, "(DOS 5.0+,NetWare4) invalid starting code segment" },
	{ 0xBD, "(DOS 5.0+,NetWare4) invalid stack segment" },
	{ 0xBE, "(DOS 5.0+,NetWare4) invalid module type (DLL can not be used as application)" },
	{ 0xBF, "(DOS 5.0+,NetWare4) invalid EXE signature" },
	{ 0xC0, "(DOS 5.0+,NetWare4) EXE marked invalid" },
	{ 0xC1, "(DOS 5.0+,NetWare4) bad EXE format (e.g. DOS-mode program)" },
	{ 0xC2, "(DOS 5.0+,NetWare4) iterated data exceeds 64K" },
	{ 0xC3, "(DOS 5.0+,NetWare4) invalid minimum allocation size" },
	{ 0xC4, "(DOS 5.0+,NetWare4) dynamic link from invalid Ring" },
	{ 0xC5, "(DOS 5.0+,NetWare4) IOPL not enabled" },
	{ 0xC6, "(DOS 5.0+,NetWare4) invalid segment descriptor privilege level" },
	{ 0xC7, "(DOS 5.0+,NetWare4) automatic data segment exceeds 64K" },
	{ 0xC8, "(DOS 5.0+,NetWare4) Ring2 segment must be moveable" },
	{ 0xC9, "(DOS 5.0+,NetWare4) relocation chain exceeds segment limit" },
	{ 0xCA, "(DOS 5.0+,NetWare4) infinite loop in relocation chain" },
	{ 0xCB, "(NetWare4) environment variable not found" },
	{ 0xCC, "(NetWare4) not current country" },
	{ 0xCD, "(NetWare4) no signal sent" },
	{ 0xCE, "(NetWare4) file name not 8.3" },
	{ 0xCF, "(NetWare4) Ring2 stack in use" },
	{ 0xD0, "(NetWare4) meta expansion is too long" },
	{ 0xD1, "(NetWare4) invalid signal number" },
	{ 0xD2, "(NetWare4) inactive thread" },
	{ 0xD3, "(NetWare4) file system information not available" },
	{ 0xD4, "(NetWare4) locked error" },
	{ 0xD5, "(NetWare4) attempted to execute non-family API call in DOS mode" },
	{ 0xD6, "(NetWare4) too many modules" },
	{ 0xD7, "(NetWare4) nesting not allowed" },
	{ 0xE6, "(NetWare4) non-existent pipe, or bad operation" },
	{ 0xE7, "(NetWare4) pipe is busy" },
	{ 0xE8, "(NetWare4) no data available for nonblocking read" },
	{ 0xE9, "(NetWare4) pipe disconnected by server" },
	{ 0xEA, "(NetWare4) more data available" },
	{ 0xFF, "(NetWare4) invalid drive" }
};

doscodes_map_t CPUDebugger::ms_disk_status = {
	{ 0x00, "successful completion" },
	{ 0x01, "invalid function in AH or invalid parameter" },
	{ 0x02, "address mark not found" },
	{ 0x03, "disk write-protected" },
	{ 0x04, "sector not found/read error" },
	{ 0x05, "reset failed (hard disk)" },
	{ 0x05, "data did not verify correctly (TI Professional PC)" },
	{ 0x06, "disk changed (floppy)" },
	{ 0x07, "drive parameter activity failed (hard disk)" },
	{ 0x08, "DMA overrun" },
	{ 0x09, "data boundary error (attempted DMA across 64K boundary or >80h sectors)" },
	{ 0x0A, "bad sector detected (hard disk)" },
	{ 0x0B, "bad track detected (hard disk)" },
	{ 0x0C, "unsupported track or invalid media" },
	{ 0x0D, "invalid number of sectors on format (PS/2 hard disk)" },
	{ 0x0E, "control data address mark detected (hard disk)" },
	{ 0x0F, "DMA arbitration level out of range (hard disk)" },
	{ 0x10, "uncorrectable CRC or ECC error on read" },
	{ 0x11, "data ECC corrected (hard disk)" },
	{ 0x20, "controller failure" },
	{ 0x31, "no media in drive (IBM/MS INT 13 extensions)" },
	{ 0x32, "incorrect drive type stored in CMOS (Compaq)" },
	{ 0x40, "seek failed" },
	{ 0x80, "timeout (not ready)" },
	{ 0xAA, "drive not ready (hard disk)" },
	{ 0xB0, "volume not locked in drive (INT 13 extensions)" },
	{ 0xB1, "volume locked in drive (INT 13 extensions)" },
	{ 0xB2, "volume not removable (INT 13 extensions)" },
	{ 0xB3, "volume in use (INT 13 extensions)" },
	{ 0xB4, "lock count exceeded (INT 13 extensions)" },
	{ 0xB5, "valid eject request failed (INT 13 extensions)" },
	{ 0xB6, "volume present but read protected (INT 13 extensions)" },
	{ 0xBB, "undefined error (hard disk)" },
	{ 0xCC, "write fault (hard disk)" },
	{ 0xE0, "status register error (hard disk)" },
	{ 0xFF, "sense operation failed (hard disk)" }
};

doscodes_map_t CPUDebugger::ms_ioctl_code = {
	{ 0x00, "(OS/2) lock drive" },
	{ 0x01, "(OS/2) unlock drive" },
	{ 0x40, "set device parameters" },
	{ 0x41, "write logical device track" },
	{ 0x42, "format and verify logical device track" },
	{ 0x46, "(DOS 4.0+) set volume serial number" },
	{ 0x47, "(DOS 4.0+) set access flag" },
	{ 0x48, "(Enh. Disk Drive Spec) set media lock state" },
	{ 0x49, "(Enh. Disk Drive Spec) eject media in drive" },
	{ 0x4A, "(MS-DOS 7.0) lock logical volume" },
	{ 0x4B, "(MS-DOS 7.0) lock physical volume" },
	{ 0x50, "(PCMCIA) attribute memory write" },
	{ 0x51, "(PCMCIA) common memory write" },
	{ 0x52, "(PCMCIA) force media change" },
	{ 0x53, "(PCMCIA) erase drive" },
	{ 0x54, "(PCMCIA) erase media" },
	{ 0x56, "(PCMCIA) set erase status callback" },
	{ 0x57, "(PCMCIA) append Card Information Structure (CIS) tuple" },
	{ 0x58, "(PCMCIA) erase CIS tuples" },
	{ 0x60, "get device parameters" },
	{ 0x61, "read logical device track" },
	{ 0x62, "verify logical device track" },
	{ 0x66, "(DOS 4.0+) get volume serial number" },
	{ 0x67, "(DOS 4.0+) get access flag" },
	{ 0x68, "(DOS 5.0+) sense media type" },
	{ 0x6A, "(MS-DOS 7.0) unlock logical volume" },
	{ 0x6B, "(MS-DOS 7.0) unlock physical volume" },
	{ 0x6C, "(MS-DOS 7.0) get lock flag" },
	{ 0x6D, "(MS-DOS 7.0) enumerate open files" },
	{ 0x6E, "(MS-DOS 7.0) find swap file" },
	{ 0x6F, "(MS-DOS 7.0) get drive map information" },
	{ 0x70, "(PCMCIA) attribute memory read" },
	{ 0x70, "(MS-DOS 7.0) get current lock state" },
	{ 0x71, "(MS-DOS 7.0) get first cluster" },
	{ 0x73, "(PCMCIA) get memory media information" },
	{ 0x76, "(PCMCIA) get erase status callback" },
	{ 0x77, "(PCMCIA) get first Card Information Structure (CIS) tuple" },
	{ 0x78, "(PCMCIA) get next CIS tuple" },
	{ 0x7F, "(PCMCIA) get ??? information" }
};

doscodes_map_t CPUDebugger::ms_int20_vxd = {
	{ 0x0001, "VMM" },
	{ 0x0002, "DEBUG" },
	{ 0x0003, "VPICD" },
	{ 0x0004, "VDMAD" },
	{ 0x0005, "VTD" },
	{ 0x0006, "V86MMGR" },
	{ 0x0007, "PageSwap" },
	{ 0x0009, "REBOOT" },
	{ 0x000A, "VDD" },
	{ 0x000B, "VSD" },
	{ 0x000C, "VMD / VMOUSE" },
	{ 0x000D, "VKD" },
	{ 0x000E, "VCD" },
	{ 0x0010, "BlockDev / IOS" },
	{ 0x0011, "VMCPD" },
	{ 0x0012, "EBIOS" },
	{ 0x0014, "VNETBIOS" },
	{ 0x0015, "DOSMGR" },
	{ 0x0017, "SHELL" },
	{ 0x0018, "VMPoll" },
	{ 0x001A, "DOSNET" },
	{ 0x001B, "VFD" },
	{ 0x001C, "LoadHi" },
	{ 0x0020, "Int13" },
	{ 0x0021, "PAGEFILE" },
	{ 0x0026, "VPOWERD" },
	{ 0x0027, "VXDLDR" },
	{ 0x0028, "NDIS" },
	{ 0x002A, "VWIN32" },
	{ 0x002B, "VCOMM" },
	{ 0x002C, "SPOOLER" },
	{ 0x0032, "VSERVER" },
	{ 0x0033, "CONFIGMG" },
	{ 0x0034, "DWCFGMG.SYS" },
	{ 0x0036, "VFBACKUP" },
	{ 0x0037, "VMINI / ENABLE" },
	{ 0x0038, "VCOND" },
	{ 0x003D, "BIOS" },
	{ 0x003E, "WSOCK" },
	{ 0x0040, "IFSMgr" },
	{ 0x0041, "VCDFSD" },
	{ 0x0048, "PERF" },
	{ 0x004A, "MTRR" },
	{ 0x004B, "NTKERN" },
	{ 0x011F, "VFLATD" },
	{ 0x0449, "vjoyd" },
	{ 0x044A, "mmdevldr" },
	{ 0x0480, "VNetSup" },
	{ 0x0481, "VREDIR" },
	{ 0x0483, "VSHARE" },
	{ 0x0487, "NWLINK" },
	{ 0x0488, "VTDI" },
	{ 0x0489, "VIP" },
	{ 0x048A, "MSTCP" },
	{ 0x048B, "VCACHE" },
	{ 0x048E, "NWREDIR" },
	{ 0x0491, "FILESEC" },
	{ 0x0492, "NWSERVER" },
	{ 0x0493, "MSSP / NWSP" },
	{ 0x0494, "NSCL" },
	{ 0x0495, "AFVXD" },
	{ 0x0496, "NDIS2SUP" },
	{ 0x0498, "Splitter" },
	{ 0x0499, "PPPMAC" },
	{ 0x049A, "VDHCP" },
	{ 0x049B, "VNBT" },
	{ 0x049D, "LOGGER" },
	{ 0x097C, "PCCARD" },
	{ 0x3048, "Frontier Technologies ???" },
	{ 0x3049, "Frontier Technologies ???" },
	{ 0x3098, "QEMM - VstlthD" },
	{ 0x30F6, "WSVV" },
	{ 0x33FC, "ASPIENUM" },
	{ 0x357E, "DSOUND" },
	{ 0x39E6, "A3D" },
	{ 0x3BFD, "CWCPROXY" },
	{ 0x3C78, "VGARTD" }
};

doscodes_map_t CPUDebugger::ms_int20_vmm = {
	{ 0x0000, "get version" },
	{ 0x0001, "get current VM handle" },
	{ 0x0002, "test current VM handle" },
	{ 0x0003, "get system VM handle" },
	{ 0x0004, "test system VM handle" },
	{ 0x0005, "validate VM handle" },
	{ 0x0006, "get VMM reenter count" },
	{ 0x0007, "begin reentrant execution" },
	{ 0x0008, "end reentrant execution" },
	{ 0x0009, "install V86 breakpoint" },
	{ 0x000A, "remove V86 breakpoint" },
	{ 0x000B, "allocate V86 callback" },
	{ 0x000C, "allocation PM callback" },
	{ 0x000D, "call when VM returns" },
	{ 0x000E, "schedule global event" },
	{ 0x000F, "schedule VM event" },
	{ 0x0010, "call global event" },
	{ 0x0011, "call VM event" },
	{ 0x0012, "cancel global event" },
	{ 0x0013, "cancel VM event" },
	{ 0x0014, "call priority VM event" },
	{ 0x0015, "cancel priority VM event" },
	{ 0x0016, "get NMI handler address" },
	{ 0x0017, "set NMI handler address" },
	{ 0x0018, "hook NMI event" },
	{ 0x0019, "call when VM interrupts enabled" },
	{ 0x001A, "enable VM interrupts" },
	{ 0x001B, "disable VM interrupts" },
	{ 0x001C, "map flat" },
	{ 0x001D, "map linear to VM address" },
	{ 0x001E, "adjust execution priority" },
	{ 0x001F, "begin critical section" },
	{ 0x0020, "end critical section" },
	{ 0x0021, "end critical section and suspend" },
	{ 0x0022, "claim critical section" },
	{ 0x0023, "release critical section" },
	{ 0x0024, "call when not critical" },
	{ 0x0025, "create semaphore" },
	{ 0x0026, "destroy semaphore" },
	{ 0x0027, "wait on semaphore" },
	{ 0x0028, "signal semaphore" },
	{ 0x0029, "get critical section status" },
	{ 0x002A, "call when task switched" },
	{ 0x002B, "suspend VM" },
	{ 0x002C, "resume VM" },
	{ 0x002D, "no-fail resume VM" },
	{ 0x002E, "nuke VM" },
	{ 0x002F, "crash current VM" },
	{ 0x0030, "get execution focus" },
	{ 0x0031, "set execution focus" },
	{ 0x0032, "get time slice priority" },
	{ 0x0033, "set time slice priority" },
	{ 0x0034, "get time slice granularity" },
	{ 0x0035, "set time slice granularity" },
	{ 0x0036, "get time slice information" },
	{ 0x0037, "adjust execution time" },
	{ 0x0038, "release time slice" },
	{ 0x0039, "wake up VM" },
	{ 0x003A, "call when idle" },
	{ 0x003B, "get next VM handle" },
	{ 0x003C, "set global timeout" },
	{ 0x003D, "set VM timeout" },
	{ 0x003E, "cancel timeout" },
	{ 0x003F, "get system time" },
	{ 0x0040, "get VM execution time" },
	{ 0x0041, "hook V86 interrupt chain" },
	{ 0x0042, "get V86 interrupt vector" },
	{ 0x0043, "set V86 interrupt vector" },
	{ 0x0044, "get PM interrupt vector" },
	{ 0x0045, "set PM interrupt vector" },
	{ 0x0046, "simulate interrupt" },
	{ 0x0047, "simulate IRET" },
	{ 0x0048, "simulate far call" },
	{ 0x0049, "simulate far jump" },
	{ 0x004A, "simulate far RET" },
	{ 0x004B, "simulate far RET N" },
	{ 0x004C, "build interrupt stack frame" },
	{ 0x004D, "simulate push" },
	{ 0x004E, "simulate pop" },
	{ 0x004F, "_HeapAllocate" },
	{ 0x0050, "_HeapReAllocate" },
	{ 0x0051, "_HeapFree" },
	{ 0x0052, "_HeapGetSize" },
	{ 0x0053, "_PageAllocate" },
	{ 0x0054, "_PageReAllocate" },
	{ 0x0055, "_PageFree" },
	{ 0x0056, "_PageLock" },
	{ 0x0057, "_PageUnLock" },
	{ 0x0058, "_PageGetSizeAddr" },
	{ 0x0059, "_PageGetAllocInfo" },
	{ 0x005A, "_GetFreePageCount" },
	{ 0x005B, "_GetSysPageCount" },
	{ 0x005C, "_GetVMPgCount" },
	{ 0x005D, "_MapIntoV86" },
	{ 0x005E, "_PhysIntoV86" },
	{ 0x005F, "_TestGlobalV86Mem" },
	{ 0x0060, "_ModifyPageBits" },
	{ 0x0061, "copy page table" },
	{ 0x0062, "map linear into V86" },
	{ 0x0063, "linear page lock" },
	{ 0x0064, "linear page unlock" },
	{ 0x0065, "_SetResetV86Pageabl" },
	{ 0x0066, "_GetV86PageableArray" },
	{ 0x0067, "_PageCheckLinRange" },
	{ 0x0068, "page out dirty pages" },
	{ 0x0069, "discard pages" },
	{ 0x006A, "_GetNulPageHandle" },
	{ 0x006B, "get first V86 page" },
	{ 0x006C, "map physical address to linear address" },
	{ 0x006D, "_GetAppFlatDSAlias" },
	{ 0x006E, "_SelectorMapFlat" },
	{ 0x006F, "_GetDemandPageInfo" },
	{ 0x0070, "_GetSetPageOutCount" },
	{ 0x0071, "hook V86 page" },
	{ 0x0072, "assign device V86 pages" },
	{ 0x0073, "deassign device V86 pages" },
	{ 0x0074, "get array of V86 pages for device" },
	{ 0x0075, "_SetNULPageAddr" },
	{ 0x0076, "allocate GDT selector" },
	{ 0x0077, "free GDT selector" },
	{ 0x0078, "allocate LDT selector" },
	{ 0x0079, "free LDT selector" },
	{ 0x007A, "_BuildDescriptorDWORDs" },
	{ 0x007B, "get descriptor" },
	{ 0x007C, "set descriptor" },
	{ 0x007D, "toggle HMA" },
	{ 0x007E, "get fault hook addresses" },
	{ 0x007F, "hook V86 fault" },
	{ 0x0080, "hook PM fault" },
	{ 0x0081, "hook VMM fault" },
	{ 0x0082, "begin nested V86 execution" },
	{ 0x0083, "begin nested execution" },
	{ 0x0084, "execute V86-mode interrupt" },
	{ 0x0085, "resume execution" },
	{ 0x0086, "end nested execution" },
	{ 0x0087, "allocate PM application callback area" },
	{ 0x0088, "get current PM application callback area" },
	{ 0x0089, "set V86 execution mode" },
	{ 0x008A, "set PM execution mode" },
	{ 0x008B, "begin using locked PM stack" },
	{ 0x008C, "end using locked PM stack" },
	{ 0x008D, "save client state" },
	{ 0x008E, "restore client state" },
	{ 0x008F, "execute VxD interrupt" },
	{ 0x0090, "hook device service" },
	{ 0x0091, "hook device V86 API" },
	{ 0x0092, "hook device PM API" },
	{ 0x0093, "system control" },
	{ 0x0094, "simulate I/O" },
	{ 0x0095, "install multiple I/O handlers" },
	{ 0x0096, "install I/O handler" },
	{ 0x0097, "enable global trapping" },
	{ 0x0098, "enable local trapping" },
	{ 0x0099, "disable global trapping" },
	{ 0x009A, "disable local trapping" },
	{ 0x009B, "create list" },
	{ 0x009C, "destroy list" },
	{ 0x009D, "allocate list" },
	{ 0x009E, "attach list" },
	{ 0x009F, "attach list tail" },
	{ 0x00A0, "insert into list" },
	{ 0x00A1, "remove from list" },
	{ 0x00A2, "deallocate list" },
	{ 0x00A3, "get first item in list" },
	{ 0x00A4, "get next item in list" },
	{ 0x00A5, "remove first item in list" },
	{ 0x00A6, "add instance item" },
	{ 0x00A7, "allocate device callback area" },
	{ 0x00A8, "allocate global V86 data area" },
	{ 0x00A9, "allocate temporary V86 data area" },
	{ 0x00AA, "free temporary V86 data area" },
	{ 0x00AB, "get decimal integer from profile" },
	{ 0x00AC, "convert decimal string to integer" },
	{ 0x00AD, "get fixed-point number from profile" },
	{ 0x00AE, "convert fixed-point string" },
	{ 0x00AF, "get hex integer from profile" },
	{ 0x00B0, "convert hex string to integer" },
	{ 0x00B1, "get boolean value from profile" },
	{ 0x00B2, "convert boolean string" },
	{ 0x00B3, "get string from profile" },
	{ 0x00B4, "get next string from profile" },
	{ 0x00B5, "get environment string" },
	{ 0x00B6, "get exec path" },
	{ 0x00B7, "get configuration directory" },
	{ 0x00B8, "open file" },
	{ 0x00B9, "get PSP segment" },
	{ 0x00BA, "get DOS vectors" },
	{ 0x00BB, "get machine information" },
	{ 0x00BC, "get/set HMA information" },
	{ 0x00BD, "set system exit code" },
	{ 0x00BE, "fatal error handler" },
	{ 0x00BF, "fatal memory error" },
	{ 0x00C0, "update system clock" },
	{ 0x00C1, "test if debugger installed" },
	{ 0x00C2, "output debugger string" },
	{ 0x00C3, "output debugger character" },
	{ 0x00C4, "input debugger character" },
	{ 0x00C5, "debugger convert hex to binary" },
	{ 0x00C6, "debugger convert hex to decimal" },
	{ 0x00C7, "debugger test if valid handle" },
	{ 0x00C8, "validate client pointer" },
	{ 0x00C9, "test reentry" },
	{ 0x00CA, "queue debugger string" },
	{ 0x00CB, "log procedure call" },
	{ 0x00CC, "debugger test current VM" },
	{ 0x00CD, "get PM interrupt type" },
	{ 0x00CE, "set PM interrupt type" },
	{ 0x00CF, "get last updated system time" },
	{ 0x00D0, "get last updated VM execution time" },
	{ 0x00D1, "test if double-byte character-set lead byte" },
	{ 0x00D2, "_AddFreePhysPage" },
	{ 0x00D3, "_PageResetHandlePAddr" },
	{ 0x00D4, "_SetLastV86Page" },
	{ 0x00D5, "_GetLastV86Page" },
	{ 0x00D6, "_MapFreePhysReg" },
	{ 0x00D7, "_UnmapFreePhysReg" },
	{ 0x00D8, "_XchgFreePhysReg" },
	{ 0x00D9, "_SetFreePhysRegCalBk" },
	{ 0x00DA, "get next arena (MCB)" },
	{ 0x00DB, "get name of ugly TSR" },
	{ 0x00DC, "get debug options" },
	{ 0x00DD, "set physical HMA alias" },
	{ 0x00DE, "_GetGlblRng0V86IntBase" },
	{ 0x00DF, "add global V86 data area" },
	{ 0x00E0, "get/set detailed VM error" },
	{ 0x00E1, "Is_Debug_Chr" },
	{ 0x00E2, "clear monochrome screen" },
	{ 0x00E3, "output character to mono screen" },
	{ 0x00E4, "output string to mono screen" },
	{ 0x00E5, "set current position on mono screen" },
	{ 0x00E6, "get current position on mono screen" },
	{ 0x00E7, "get character from mono screen" },
	{ 0x00E8, "locate byte in ROM" },
	{ 0x00E9, "hook invalid page fault" },
	{ 0x00EA, "unhook invalid page fault" },
	{ 0x00EB, "set delete on exit file" },
	{ 0x00EC, "close VM" },
	{ 0x00ED, "Enable_Touch_1st_Meg" },
	{ 0x00EE, "Disable_Touch_1st_Meg" },
	{ 0x00EF, "install exception handler" },
	{ 0x00F0, "remove exception handler" },
	{ 0x00F1, "Get_Crit_Status_No_Block" },
	{ 0x00F2, "_Schedule_VM_RTI_Event" },
	{ 0x00F3, "_Trace_Out_Service" },
	{ 0x00F4, "_Debug_Out_Service" },
	{ 0x00F5, "_Debug_Flags_Service" },
	{ 0x00F6, "VMM add import module name" },
	{ 0x00F7, "VMM Add DDB" },
	{ 0x00F8, "VMM Remove DDB" },
	{ 0x00F9, "get thread time slice priority" },
	{ 0x00FA, "set thread time slice priority" },
	{ 0x00FB, "schedule thread event" },
	{ 0x00FC, "cancel thread event" },
	{ 0x00FD, "set thread timeout" },
	{ 0x00FE, "set asynchronous timeout" },
	{ 0x00FF, "_AllocatreThreadDataSlot" },
	{ 0x0100, "_FreeThreadDataSlot" },
	{ 0x0101, "create Mutex" },
	{ 0x0102, "destroy Mutex" },
	{ 0x0103, "get Mutex owner" },
	{ 0x0104, "call when thread switched" },
	{ 0x0105, "create thread" },
	{ 0x0106, "start thread" },
	{ 0x0107, "terminate thread" },
	{ 0x0108, "get current thread handle" },
	{ 0x0109, "test current thread handle" },
	{ 0x010A, "Get_Sys_Thread_Handle" },
	{ 0x010B, "Test_Sys_Thread_Handle" },
	{ 0x010C, "Validate_Thread_Handle" },
	{ 0x010D, "Get_Initial_Thread_Handle" },
	{ 0x010E, "Test_Initial_Thread_Handle" },
	{ 0x010F, "Debug_Test_Valid_Thread_Handle" },
	{ 0x0110, "Debug_Test_Cur_Thread" },
	{ 0x0111, "VMM_GetSystemInitState" },
	{ 0x0112, "Cancel_Call_When_Thread_Switched" },
	{ 0x0113, "Get_Next_Thread_Handle" },
	{ 0x0114, "Adjust_Thread_Exec_Priority" },
	{ 0x0115, "_Deallocate_Device_CB_Area" },
	{ 0x0116, "Remove_IO_Handler" },
	{ 0x0117, "Remove_Mult_IO_Handlers" },
	{ 0x0118, "unhook V86 interrupt chain" },
	{ 0x0119, "unhook V86 fault handler" },
	{ 0x011A, "unhook PM fault handler" },
	{ 0x011B, "unhook VMM fault handler" },
	{ 0x011C, "unhook device service" },
	{ 0x011D, "_PageReserve" },
	{ 0x011E, "_PageCommit" },
	{ 0x011F, "_PageDecommit" },
	{ 0x0120, "_PagerRegister" },
	{ 0x0121, "_PagerQuery" },
	{ 0x0122, "_PagerDeregister" },
	{ 0x0123, "_ContextCreate" },
	{ 0x0124, "_ContextDestroy" },
	{ 0x0125, "_PageAttach" },
	{ 0x0126, "_PageFlush" },
	{ 0x0127, "_SignalID" },
	{ 0x0128, "_PageCommitPhys" },
	{ 0x0129, "_Register_Win32_Services" },
	{ 0x012A, "Cancel_Call_When_Not_Critical" },
	{ 0x012B, "Cancel_Call_When_Idle" },
	{ 0x012C, "Cancel_Call_When_Task_Switched" },
	{ 0x012D, "_Debug_Printf_Service" },
	{ 0x012E, "enter Mutex" },
	{ 0x012F, "leave Mutex" },
	{ 0x0130, "simulate VM I/O" },
	{ 0x0131, "Signal_Semaphore_No_Switch" },
	{ 0x0132, "_MMSwitchContext" },
	{ 0x0133, "_MMModifyPermissions" },
	{ 0x0134, "_MMQuery" },
	{ 0x0135, "_EnterMustComplete" },
	{ 0x0136, "_LeaveMustComplete" },
	{ 0x0137, "_ResumeExecMustComplete" },
	{ 0x0138, "get thread termination status" },
	{ 0x0139, "_GetInstanceInfo" },
	{ 0x013A, "_ExecIntMustComplete" },
	{ 0x013B, "_ExecVxDIntMustComplete" },
	{ 0x013C, "begin V86 serialization" },
	{ 0x013D, "unhook V86 page" },
	{ 0x013E, "VMM_GetVxDLocationList" },
	{ 0x013F, "VMM_GetDDBList" },
	{ 0x0140, "unhook NMI event" },
	{ 0x0141, "Get_Instanced_V86_Int_Vector" },
	{ 0x0142, "get or set real DOS PSP" },
	{ 0x0143, "call priority thread event" },
	{ 0x0144, "Get_System_Time_Address" },
	{ 0x0145, "Get_Crit_Status_Thread" },
	{ 0x0146, "Get_DDB" },
	{ 0x0147, "Directed_Sys_Control" },
	{ 0x0148, "_RegOpenKey" },
	{ 0x0149, "_RegCloseKey" },
	{ 0x014A, "_RegCreateKey" },
	{ 0x014B, "_RegDeleteKey" },
	{ 0x014C, "_RegEnumKey" },
	{ 0x014D, "_RegQueryValue" },
	{ 0x014E, "_RegSetValue" },
	{ 0x014F, "_RegDeleteValue" },
	{ 0x0150, "_RegEnumValue" },
	{ 0x0151, "_RegQueryValueEx" },
	{ 0x0152, "_RegSetValueEx" },
	{ 0x0153, "_CallRing3" },
	{ 0x0154, "Exec_PM_Int" },
	{ 0x0155, "_RegFlushKey" },
	{ 0x0156, "_PageCommitContig" },
	{ 0x0157, "_GetCurrentContext" },
	{ 0x0158, "_LocalizeSprintf" },
	{ 0x0159, "_LocalizeStackSprintf" },
	{ 0x015A, "Call_Restricted_Event" },
	{ 0x015B, "Cancel_Restricted_Event" },
	{ 0x015C, "Register_PEF_Provider" },
	{ 0x015D, "_GetPhysPageInfo" },
	{ 0x015E, "_RegQueryInfoKey" },
	{ 0x015F, "MemArb_Reserve_Pages" },
	{ 0x0160, "Time_Slice_Sys_VM_Idle" },
	{ 0x0161, "Time_Slice_Sleep" },
	{ 0x0162, "Boost_With_Decay" },
	{ 0x0163, "Set_Inversion_Pri" },
	{ 0x0164, "Reset_Inversion_Pri" },
	{ 0x0165, "Release_Inversion_Pri" },
	{ 0x0166, "Get_Thread_Win32_Pri" },
	{ 0x0167, "Set_Thread_Win32_Pri" },
	{ 0x0168, "Set_Thread_Static_Boost" },
	{ 0x0169, "Set_VM_Static_Boost" },
	{ 0x016A, "Release_Inversion_Pri_ID" },
	{ 0x016B, "Attach_Thread_To_Group" },
	{ 0x016C, "Detach_Thread_From_Group" },
	{ 0x016D, "Set_Group_Static_Boost" },
	{ 0x016E, "_GetRegistryPath" },
	{ 0x016F, "_GetRegistryKey" },
	{ 0x0170, "_CleanupNestedExec" },
	{ 0x0171, "_RegRemapPreDefKey" },
	{ 0x0172, "End_V86_Serialization" },
	{ 0x0173, "_Assert_Range" },
	{ 0x0174, "_Sprintf" },
	{ 0x0175, "_PageChangePager" },
	{ 0x0176, "_RegCreateDynKey" },
	{ 0x0177, "RegQMulti" },
	{ 0x0178, "Boost_Thread_With_VM" },
	{ 0x0179, "Get_Boot_Flags" },
	{ 0x017A, "Set_Boot_Flags" },
	{ 0x017B, "_lstrcpyn" },
	{ 0x017C, "_lstrlen" },
	{ 0x017D, "_lmemcpy" },
	{ 0x017E, "_GetVxDName" },
	{ 0x017F, "Force_Mutexes_Free" },
	{ 0x0180, "Restore_Forced_Mutexes" },
	{ 0x0181, "_AddReclaimableItem" },
	{ 0x0182, "_SetReclaimableItem" },
	{ 0x0183, "_EnumReclaimableItem" },
	{ 0x0184, "Time_Slice_Wake_Sys_VM" },
	{ 0x0185, "VMM_Replace_Global_Environment" },
	{ 0x0186, "Begin_Non_Serial_Nest_V86_Exec" },
	{ 0x0187, "Get_Nest_Exec_Status" },
	{ 0x0188, "Open_Boot_Log" },
	{ 0x0189, "Write_Boot_Log" },
	{ 0x018A, "Close_Boot_Log" },
	{ 0x018B, "EnableDisable_Boot_Log" },
	{ 0x018C, "_Call_On_My_Stack" },
	{ 0x018D, "Get_Inst_V86_Int_Vec_Base" },
	{ 0x018E, "_lstrcmpi" },
	{ 0x018F, "_strupr" },
	{ 0x0190, "Log_Fault_Call_Out" },
	{ 0x0191, "_AtEventTime" },
	{ 0x811C, "unhook device service?" }
};
