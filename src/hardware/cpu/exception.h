/*
 * Copyright (C) 2018  Marco Bortolin
 *
 * This file is part of IBMulator.
 *
 * IBMulator is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * IBMulator is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with IBMulator.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef IBMULATOR_HW_CPU_EXCEPTION_H
#define IBMULATOR_HW_CPU_EXCEPTION_H

/* Interrupts and exceptions are special cases of control transfer within a
 * program. An interrupt occurs as a result of an event that is independent of
 * the currently executing program, while exceptions are a direct result of the
 * program currently being executed, Interrupts may be external or internal.
 * External interrupts are generated by either the INTR or NMI input pins.
 * Internal interrupts are caused by the INT instruction. Exceptions occur when
 * an instruction cannot be completed normally. (cfr. 9-1)
 */
enum CPUExceptionVector {
	CPU_DIV_ER_EXC      = 0,  // #DE Divide Error exception
	CPU_DEBUG_EXC       = 1,  // #DB Breakpoint/Single step interrupt (286) - Debug (386)
	CPU_NMI_INT         = 2,  //     NMI interrupt
	CPU_BREAKPOINT_INT  = 3,  // #BP INT3 (breakpoint) interrupt
	CPU_INTO_EXC        = 4,  // #OF INTO detected overflow exception
	CPU_BOUND_EXC       = 5,  // #BR BOUND range exceeded exception
	CPU_UD_EXC          = 6,  // #UD Undefined opcode exception (rmode/pmode)
	CPU_NM_EXC          = 7,  // #NM NPX not available exception (rmode/pmode)
	CPU_IDT_LIMIT_EXC   = 8,  //     Interrupt table limit too small exception (rmode)
	CPU_DF_EXC          = 8,  // #DF Double Fault exception (pmode)
	CPU_NPX_SEG_OVR_INT = 9,  //     NPX segment overrun interrupt (rmode)
	CPU_MP_EXC          = 9,  // #MP NPX protection fault exception (pmode)
	CPU_TS_EXC          = 10, // #TS Invalid Task State Segment exception (pmode)
	CPU_NP_EXC          = 11, // #NP Segment Not Present exception (pmode)
	CPU_SS_EXC          = 12, // #SS Stack Fault exception (pmode)
	CPU_SEG_OVR_EXC     = 13, //     Segment overrun exception (rmode)
	CPU_GP_EXC          = 13, // #GP General Protection exception (pmode)
	CPU_PF_EXC          = 14, // #PF Page fault (pmode)
	//                    15  //     Reserved
	CPU_NPX_ERR_INT     = 16, //     NPX error interrupt (rmode)
	CPU_MF_EXC          = 16, // #MF Math Fault exception (pmode)

	CPU_MAX_INT,
	CPU_INVALID_INT = CPU_MAX_INT
};

// exception types for interrupt method
enum CPUInterruptType {
	CPU_EXTERNAL_INTERRUPT = 0,
	CPU_NMI = 2,
	CPU_HARDWARE_EXCEPTION = 3,  // all exceptions except #BP and #OF
	CPU_SOFTWARE_INTERRUPT = 4,
	CPU_PRIVILEGED_SOFTWARE_INTERRUPT = 5,
	CPU_SOFTWARE_EXCEPTION = 6
};

enum CPUExceptionType {
	CPU_BENIGN_EXC       = 0,
	CPU_CONTRIBUTORY_EXC = 1,
	CPU_PAGE_FAULTS      = 2,
	CPU_DOUBLE_FAULT
};

enum CPUExceptionClass {
	CPU_FAULT_EXC = 0,
	CPU_TRAP_EXC  = 1,
	CPU_ABORT_EXC = 2,
};

struct CPUExceptionInfo
{
	unsigned exc_type;
	unsigned exc_class;
	bool push_error;
};

extern const CPUExceptionInfo g_cpu_exceptions[];

class CPUException
{
public:
	uint8_t vector;
	uint16_t error_code;

	CPUException() : vector(CPU_INVALID_INT), error_code(0) { }
	CPUException(uint8_t _vector, uint16_t _error_code)
	: vector(_vector), error_code(_error_code) { }
};

class CPUShutdown : public std::runtime_error
{
public:
	CPUShutdown(const char *_what) : std::runtime_error(_what) {}
};

#endif
